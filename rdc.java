public class rdc {
	
	/* expr
     Parses strings in the language generated by the rule:
     <expr> -> <term> {(+ | -) <term>}
     */
	public static void expr() {
		System.out.println("Enter <expr>");
		/* Parse the first term */
		term();
	/* As long as the next token is + or -, get
	 the next token and parse the next term */
		while (nextToken.compareTo(ADD_OP) || nextToken.compareTo(SUB_OP)) {
			lex();
			term();
		}
		Systen.out.println("Exit <expr>");
	}

	/* term
     Parses strings in the language generated by the rule:
     <term> -> <factor> {(* | /) <factor>}
     */
	public static void term() {
		System.out.println("Enter <term>");
		/* Parse the first factor */
		factor();
	/* As long as the next token is * or /, get the
	 next token and parse the next factor */
		while (nextToken.compareTo(MULT_OP) || nextToken.compareTo(DIV_OP)) {
			lex();
			factor();
		}
		System.out.println("Exit <term>");
	}

	/* factor
     Parses strings in the language generated by the rule:
     <factor> -> id | int_constant | ( <expr> )
     */
	public static void factor() {
		System.out.println("Enter <factor>");
		/* Determine which RHS */
		if (nextToken.compareTo(IDENT) || nextToken.compareTo(INT_LIT)){
			/* Get the next token */
			lex();
		/* If the RHS is ( <expr> ), call lex to pass over the
		 left parenthesis, call expr, and check for the right
		 parenthesis */
		}else { if (nextToken.compareTo(LEFT_PAREN)) {
			lex();
			expr();
			if (nextToken.compareTo(RIGHT_PAREN)){
				lex();
		;
			}else{
				error();
			}
		}
			System.out.println("Exit <factor>");
		}
	}
	public static void main(String[] args) {
		return;
	}

}


